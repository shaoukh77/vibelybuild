/**
 * Publisher - GitHub Integration & Deployment Utilities
 *
 * This module handles:
 * - Creating GitHub repositories via Octokit
 * - Pushing generated code to GitHub
 * - Updating Firestore with repo URLs and deployment status
 * - Triggering deployments (Vercel/Netlify - future)
 *
 * Environment Variables Required:
 * - GITHUB_TOKEN: GitHub personal access token with repo permissions
 * - GITHUB_OWNER: GitHub username/organization
 * - GITHUB_DEFAULT_BRANCH: Default branch name (usually "main")
 */

import { Octokit } from "@octokit/rest";
import { AppBlueprint } from "./llmProvider";
import { adminDb } from "./firebase-admin";
import admin from "./firebase-admin";

export interface PublishOptions {
  buildId: string;
  blueprint: AppBlueprint;
  userId: string;
  repoName?: string;
  private?: boolean;
  generatedFiles?: { path: string; content: string }[];
}

export interface DeploymentResult {
  success: boolean;
  repoUrl?: string;
  deployUrl?: string;
  error?: string;
}

/**
 * Create a GitHub repository and push generated code
 *
 * This function:
 * 1. Validates GitHub credentials from env
 * 2. Creates a new private repository
 * 3. Generates minimal project files (README, .gitignore, or provided files)
 * 4. Commits and pushes to the default branch
 * 5. Updates Firestore with repo URL and status
 *
 * @param build - Build object with id, appName, blueprint, and optional files
 * @returns Deployment result with repo URL
 */
export async function publishToGitHub(build: {
  id: string;
  appName: string;
  blueprint: AppBlueprint;
  userId: string;
  generatedFiles?: { path: string; content: string }[];
}): Promise<DeploymentResult> {
  const { id: buildId, appName, blueprint, userId, generatedFiles } = build;

  // Validate environment variables
  const githubToken = process.env.GITHUB_TOKEN;
  const githubOwner = process.env.GITHUB_OWNER;
  const defaultBranch = process.env.GITHUB_DEFAULT_BRANCH || "main";

  if (!githubToken) {
    console.warn("‚ö†Ô∏è  GITHUB_TOKEN not configured. Skipping GitHub publish.");
    return {
      success: false,
      error: "GITHUB_TOKEN not configured",
    };
  }

  if (!githubOwner) {
    console.warn("‚ö†Ô∏è  GITHUB_OWNER not configured. Skipping GitHub publish.");
    return {
      success: false,
      error: "GITHUB_OWNER not configured",
    };
  }

  try {
    console.log("üì¶ [Publisher] Starting GitHub publish");
    console.log(`   Build ID: ${buildId}`);
    console.log(`   App Name: ${appName}`);
    console.log(`   Target: ${blueprint.target}`);
    console.log(`   Owner: ${githubOwner}`);

    // Initialize Octokit
    const octokit = new Octokit({ auth: githubToken });

    // Generate repository name
    const repoName = `vibelybuild-${buildId}`;
    console.log(`   Repo Name: ${repoName}`);

    // Step 1: Create repository
    console.log("üìÅ Creating GitHub repository...");
    const { data: repo } = await octokit.repos.createForAuthenticatedUser({
      name: repoName,
      description: `${appName} - Built with VibelyBuild.AI`,
      private: true,
      auto_init: false, // We'll create initial commit manually
    });

    console.log(`‚úÖ Repository created: ${repo.html_url}`);
    const repoUrl = repo.html_url;

    // Step 2: Prepare files to commit
    const files = generatedFiles && generatedFiles.length > 0
      ? generatedFiles
      : generateMinimalProjectFiles(appName, blueprint);

    console.log(`üìÑ Preparing ${files.length} files for initial commit...`);

    // Step 3: Create blobs for each file
    const blobs = await Promise.all(
      files.map(async (file) => {
        const { data: blob } = await octokit.git.createBlob({
          owner: githubOwner,
          repo: repoName,
          content: Buffer.from(file.content).toString("base64"),
          encoding: "base64",
        });
        return { path: file.path, sha: blob.sha };
      })
    );

    // Step 4: Create tree
    const { data: tree } = await octokit.git.createTree({
      owner: githubOwner,
      repo: repoName,
      tree: blobs.map((blob) => ({
        path: blob.path,
        mode: "100644" as const,
        type: "blob" as const,
        sha: blob.sha,
      })),
    });

    // Step 5: Create commit
    const { data: commit } = await octokit.git.createCommit({
      owner: githubOwner,
      repo: repoName,
      message: `Initial commit: ${appName}\n\nGenerated by VibelyBuild.AI`,
      tree: tree.sha,
      parents: [], // Initial commit has no parents
    });

    // Step 6: Update branch reference
    await octokit.git.createRef({
      owner: githubOwner,
      repo: repoName,
      ref: `refs/heads/${defaultBranch}`,
      sha: commit.sha,
    });

    console.log(`‚úÖ Code pushed to ${defaultBranch} branch`);
    console.log(`üîó Repository URL: ${repoUrl}`);

    // Step 7: Update Firestore with repo URL and status
    await updateFirestoreAfterPublish(buildId, repoUrl);

    return {
      success: true,
      repoUrl,
    };
  } catch (error: any) {
    console.error("‚ùå [Publisher] GitHub publish failed:", error);

    // Update Firestore with error status
    await updateFirestoreWithError(buildId, error.message);

    return {
      success: false,
      error: error.message || "GitHub publish failed",
    };
  }
}

/**
 * Update Firestore after successful GitHub publish
 */
async function updateFirestoreAfterPublish(
  buildId: string,
  repoUrl: string
): Promise<void> {
  try {
    const buildRef = adminDb.collection("builds").doc(buildId);
    await buildRef.update({
      repoUrl,
      deployStatus: "repo-created",
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    });
    console.log("‚úÖ Firestore updated with repo URL");
  } catch (error) {
    console.error("‚ö†Ô∏è  Failed to update Firestore:", error);
    // Don't throw - GitHub publish was successful, Firestore update is secondary
  }
}

/**
 * Update Firestore with error status
 */
async function updateFirestoreWithError(
  buildId: string,
  errorMessage: string
): Promise<void> {
  try {
    const buildRef = adminDb.collection("builds").doc(buildId);
    await buildRef.update({
      deployStatus: "repo-error",
      deployError: errorMessage,
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    });
  } catch (error) {
    console.error("‚ö†Ô∏è  Failed to update Firestore with error:", error);
  }
}

/**
 * Generate minimal project files for a new repository
 */
function generateMinimalProjectFiles(
  appName: string,
  blueprint: AppBlueprint
): { path: string; content: string }[] {
  const files: { path: string; content: string }[] = [];

  // README.md
  files.push({
    path: "README.md",
    content: `# ${appName}

Built with **VibelyBuild.AI** - AI-powered app development platform.

## Overview

${blueprint.notes || `This is a ${blueprint.target} application with ${blueprint.pages.length} pages.`}

## Target Platform

- **Platform:** ${blueprint.target}
- **Pages:** ${blueprint.pages.length}
- **Data Entities:** ${blueprint.dataModel.length}
- **Authentication:** ${blueprint.authRequired ? "Required" : "Not required"}

## Pages

${blueprint.pages.map((page) => `- **${page.title}** (\`${page.route}\`) - ${page.layout} layout`).join("\n")}

${blueprint.dataModel.length > 0 ? `
## Data Model

${blueprint.dataModel.map((entity) => `- **${entity.name}** (${entity.fields.length} fields)`).join("\n")}
` : ""}

## Getting Started

This is a generated project structure. To build the full application:

1. Install dependencies
2. Configure your environment variables
3. Run the development server

---

**Generated by VibelyBuild.AI** - [https://vibelybuild.ai](https://vibelybuild.ai)
`,
  });

  // .gitignore
  files.push({
    path: ".gitignore",
    content: `# Dependencies
node_modules/
.pnp
.pnp.js

# Testing
coverage/

# Next.js
.next/
out/
build/

# Production
dist/

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Misc
*.log
`,
  });

  // blueprint.json - Store the full blueprint for reference
  files.push({
    path: "blueprint.json",
    content: JSON.stringify(blueprint, null, 2),
  });

  return files;
}

/**
 * Deploy to Vercel (STUB - Future implementation)
 */
export async function deployToVercel(
  options: PublishOptions
): Promise<DeploymentResult> {
  const { buildId, blueprint } = options;

  console.log("üöÄ [Publisher] Vercel deployment not yet implemented");
  console.log(`   Build ID: ${buildId}`);
  console.log(`   App Name: ${blueprint.appName}`);

  // TODO: Implement Vercel API integration
  // 1. Read VERCEL_TOKEN from env
  // 2. Create Vercel project
  // 3. Link to GitHub repo
  // 4. Trigger deployment
  // 5. Return deploy URL

  return {
    success: false,
    error: "Vercel deployment not yet implemented",
  };
}

/**
 * Deploy to Netlify (STUB - Future implementation)
 */
export async function deployToNetlify(
  options: PublishOptions
): Promise<DeploymentResult> {
  const { buildId, blueprint } = options;

  console.log("üöÄ [Publisher] Netlify deployment not yet implemented");

  // TODO: Implement Netlify API integration

  return {
    success: false,
    error: "Netlify deployment not yet implemented",
  };
}

/**
 * Prepare mobile app build (STUB - Future implementation)
 */
export async function prepareMobileBuild(
  options: PublishOptions
): Promise<DeploymentResult> {
  const { buildId, blueprint } = options;

  console.log("üì± [Publisher] Mobile build not yet implemented");

  // TODO: Generate React Native/Expo project

  return {
    success: false,
    error: "Mobile build not yet implemented",
  };
}

/**
 * Check if publishing is configured
 */
export function getPublishCapabilities() {
  return {
    github: !!(process.env.GITHUB_TOKEN && process.env.GITHUB_OWNER),
    vercel: !!process.env.VERCEL_TOKEN,
    netlify: !!process.env.NETLIFY_TOKEN,
    expo: !!process.env.EXPO_TOKEN,
  };
}

/**
 * DEBUGGING: Manual trigger for GitHub publish
 *
 * To test this manually from Node.js:
 *
 * ```javascript
 * import { publishToGitHub } from './src/lib/publisher';
 *
 * const testBuild = {
 *   id: 'test-123',
 *   appName: 'Test App',
 *   blueprint: {
 *     appName: 'Test App',
 *     target: 'web',
 *     pages: [{
 *       id: 'home',
 *       title: 'Home',
 *       route: '/',
 *       layout: 'landing',
 *       sections: [{ type: 'hero', title: 'Welcome' }]
 *     }],
 *     dataModel: [],
 *     authRequired: false
 *   },
 *   userId: 'user-123'
 * };
 *
 * publishToGitHub(testBuild)
 *   .then(result => console.log('Success:', result))
 *   .catch(error => console.error('Error:', error));
 * ```
 *
 * Or use the build ID from Firestore:
 *
 * ```javascript
 * import { doc, getDoc } from 'firebase/firestore';
 * import { db } from './src/lib/firebase';
 * import { publishToGitHub } from './src/lib/publisher';
 *
 * async function publishExistingBuild(buildId) {
 *   const buildRef = doc(db, 'builds', buildId);
 *   const buildSnap = await getDoc(buildRef);
 *
 *   if (!buildSnap.exists()) {
 *     throw new Error('Build not found');
 *   }
 *
 *   const buildData = buildSnap.data();
 *   const result = await publishToGitHub({
 *     id: buildId,
 *     appName: buildData.appName || 'My App',
 *     blueprint: buildData.blueprint,
 *     userId: buildData.userId
 *   });
 *
 *   console.log('Publish result:', result);
 * }
 *
 * // Usage: publishExistingBuild('your-build-id-here');
 * ```
 */
